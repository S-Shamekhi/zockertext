#include <errno.h>
#include <stdio.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

#include "setup.h"

static int copy_file(const char *src, const char *dst, mode_t mode);
static int setup_bin_dir(const char container_dir[256]);
static int setup_lib_dir(const char container_dir[256]);

static int copy_file(const char *src, const char *dst, mode_t mode) {
  int in = open(src, O_RDONLY);
  if (in == -1) {
    fprintf(stderr, "[ERR] Failed to open %s for reading\n", src);
    return 1;
  }

  int out = open(dst, O_WRONLY | O_CREAT | O_TRUNC, mode);
  if (out == -1) {
    fprintf(stderr, "[ERR] Failed to open %s for writing\n", dst);
    close(in);
    return 1;
  }

  char buf[4096];
  ssize_t n;
  while ((n = read(in, buf, sizeof(buf))) > 0) {
    ssize_t w = write(out, buf, n);
    if (w != n) {
      fprintf(stderr, "[ERR] Short write while copying %s to %s\n", src, dst);
      close(in);
      close(out);
      return 1;
    }
  }

  if (n < 0) {
    fprintf(stderr, "[ERR] Failed to read from %s\n", src);
    close(in);
    close(out);
    return 1;
  }

  close(in);
  close(out);
  return 0;
}



int setup_zocker_dir(void) {
  struct stat st;
  char prefix[64];

  if (snprintf(prefix, sizeof(prefix), "%s", ZOCKER_PREFIX) < 0) {
    return 1;
  }

  if (stat(prefix, &st) == -1) {
    if (errno == ENOENT) {
      fprintf(stderr, "[ERR] ZOCKER_PREFIX %s does not exists\n",
              ZOCKER_PREFIX);
    }
    return 1;
  }

  if (!S_ISDIR(st.st_mode)) {
    fprintf(stderr, "[ERR] ZOCKER_PREFIX %s is not a directory\n",
            ZOCKER_PREFIX);
    return 1;
  }

  return 0;
}

int setup_container_dir(const char id[64], char container_dir[256]) {
  struct stat st;
  const size_t buffer_size = 256;

  if (snprintf(container_dir, buffer_size, "%s/%s", ZOCKER_PREFIX, id) < 0) {
    return 1;
  }

  if (stat(container_dir, &st) == -1) {
    if (errno != ENOENT) {
      return 1;
    }

    if (mkdir(container_dir, 0755) == -1) {
      fprintf(stderr, "[ERR] Failed to create container directory %s\n",
              container_dir);
      return 1;
    }
  } else if (!S_ISDIR(st.st_mode)) {
    fprintf(stderr, "[ERR] Path %s is not a directory\n", container_dir);
    return 1;
  }

  if (setup_bin_dir(container_dir) != 0) {
    fprintf(stderr, "[ERR] Failed to setup bin directory for container %s\n",
            id);
    return 1;
  }

  if (setup_lib_dir(container_dir) != 0) {
    fprintf(stderr, "[ERR] Failed to setup lib directory for container %s\n",
            id);
    return 1;
  }

  return 0;
}

static int setup_bin_dir(const char container_dir[256]) {
  char bin_dir[256];
  if (snprintf(bin_dir, sizeof(bin_dir), "%s/bin", container_dir) < 0) {
    return 1;
  }

  // Create /bin inside the container root (ignore if it already exists)
  if (mkdir(bin_dir, 0755) == -1 && errno != EEXIST) {
    fprintf(stderr, "[ERR] Failed to create bin directory %s\n", bin_dir);
    return 1;
  }

  // Copy /bin/sh from host into container as /bin/sh
  char dst_sh[256];
  if (snprintf(dst_sh, sizeof(dst_sh), "%s/sh", bin_dir) < 0) {
    return 1;
  }

  // On your system /bin/sh -> dash (verified by ls -l /bin/sh)
  if (copy_file("/bin/sh", dst_sh, 0755) != 0) {
    fprintf(stderr, "[ERR] Failed to copy /bin/sh into container\n");
    return 1;
  }

  return 0;
}


static int setup_lib_dir(const char container_dir[256]) {
  char lib_dir[256];
  char lib64_dir[256];

  // Create /lib and /lib64 in the container (ignore if they already exist)
  if (snprintf(lib_dir, sizeof(lib_dir), "%s/lib", container_dir) < 0) {
    return 1;
  }
  if (mkdir(lib_dir, 0755) == -1 && errno != EEXIST) {
    fprintf(stderr, "[ERR] Failed to create lib directory %s\n", lib_dir);
    return 1;
  }

  if (snprintf(lib64_dir, sizeof(lib64_dir), "%s/lib64", container_dir) < 0) {
    return 1;
  }
  if (mkdir(lib64_dir, 0755) == -1 && errno != EEXIST) {
    fprintf(stderr, "[ERR] Failed to create lib64 directory %s\n", lib64_dir);
    return 1;
  }

  // From `ldd /bin/sh`:
  //   libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6
  //   /lib64/ld-linux-x86-64.so.2
  const char *src_libc   = "/lib/x86_64-linux-gnu/libc.so.6";
  const char *src_loader = "/lib64/ld-linux-x86-64.so.2";

  // 1) Copy the dynamic loader to container's /lib64
  {
    char dst[256];
    if (snprintf(dst, sizeof(dst),
                 "%s/lib64/ld-linux-x86-64.so.2", container_dir) < 0) {
      return 1;
    }
    if (copy_file(src_loader, dst, 0755) != 0) {
      fprintf(stderr, "[ERR] Failed to copy loader %s\n", src_loader);
      return 1;
    }
  }

  // 2) Make subdirectory for x86_64 libraries: /lib/x86_64-linux-gnu
  char arch_lib_dir[256];
  if (snprintf(arch_lib_dir, sizeof(arch_lib_dir),
               "%s/lib/x86_64-linux-gnu", container_dir) < 0) {
    return 1;
  }
  if (mkdir(arch_lib_dir, 0755) == -1 && errno != EEXIST) {
    fprintf(stderr, "[ERR] Failed to create %s\n", arch_lib_dir);
    return 1;
  }

  // 3) Copy libc.so.6 into that directory
  {
    char dst[256];
    if (snprintf(dst, sizeof(dst),
                 "%s/lib/x86_64-linux-gnu/libc.so.6", container_dir) < 0) {
      return 1;
    }
    if (copy_file(src_libc, dst, 0644) != 0) {
      fprintf(stderr, "[ERR] Failed to copy %s\n", src_libc);
      return 1;
    }
  }

  return 0;
}
