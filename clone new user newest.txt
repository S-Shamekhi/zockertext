int run_container(struct config cfg) {
    /* 1. User namespace – MUST be created FIRST */
    if (unshare(CLONE_NEWUSER) < 0) {
        perror("unshare CLONE_NEWUSER");
        return 1;
    }

    /* Map host UID/GID → root inside container */
    FILE *f;
    f = fopen("/proc/self/uid_map", "w");
    if (f) { fprintf(f, "0 %d 1\n", getuid()); fclose(f); }
    f = fopen("/proc/self/gid_map", "w");
    if (f) { fprintf(f, "0 %d 1\n", getgid()); fclose(f); }

    /* 2. Mount namespace + make everything private */
    if (unshare(CLONE_NEWNS) < 0) {
        perror("unshare CLONE_NEWNS");
        return 1;
    }
    if (mount(NULL, "/", NULL, MS_REC | MS_PRIVATE, NULL) < 0) {
        perror("mount MS_PRIVATE");
        return 1;
    }

    /* 3. PID and UTS namespaces */
    if (unshare(CLONE_NEWPID) < 0) { perror("unshare CLONE_NEWPID"); return 1; }
    if (unshare(CLONE_NEWUTS) < 0) { perror("unshare CLONE_NEWUTS"); return 1; }

    pid_t pid = fork();
    if (pid < 0) { perror("fork"); return 1; }

    if (pid == 0) {  // Inside container
        mkdir("/proc", 0755);
        if (mount("proc", "/proc", "proc", 0, NULL) < 0) {
            perror("mount /proc");
            _exit(1);
        }

        if (strlen(cfg.name) > 0)
            sethostname(cfg.name, strlen(cfg.name));

        printf("Running child with pid: %d\n", getpid());
        execl("/bin/sh", "sh", "-c", cfg.command, NULL);
        perror("execl");
        _exit(1);
    } else {
        printf("[Parent] Child created with real-pid: %d (still in host namespace)\n", pid);
        waitpid(pid, NULL, 0);
        printf("[Parent] Done.\n");
        return 0;
    }
}